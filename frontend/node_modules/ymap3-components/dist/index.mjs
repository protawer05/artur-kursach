import r, { createContext as v, useContext as f, useState as M, useMemo as Y, useEffect as w, useLayoutEffect as D } from "react";
import h from "react-dom";
var c = /* @__PURE__ */ ((e) => (e.CartesianProjection = "@yandex/ymaps3-cartesian-projection@0.0.1", e.Clusterer = "@yandex/ymaps3-clusterer@0.0.1", e.Controls = "@yandex/ymaps3-controls@0.0.1", e.Hint = "@yandex/ymaps3-hint@0.0.1", e.Markers = "@yandex/ymaps3-markers@0.0.1", e.SphericalMercatorProjection = "@yandex/ymaps3-spherical-mercator-projection@0.0.1", e))(c || {});
const C = v({}), H = v({
  hint: void 0
}), L = ({
  children: e,
  context: t
}) => {
  const n = f(t);
  return /* @__PURE__ */ r.createElement(H.Provider, { value: n }, e);
}, B = ({ children: e, hint: t }) => {
  const { reactify: n, ymaps: y } = f(
    C
  ), [p, u] = M(), s = Y(() => {
    if (p) {
      const o = window[c.Hint];
      return n.module(o).YMapHint;
    }
  }, [p]);
  return w(() => {
    if (window[c.Hint]) {
      const o = window[c.Hint];
      u(n.module(o).YMapHintContext);
    } else
      y.import(c.Hint).then((o) => {
        window[c.Hint] = o, n.module(o) && u(n.module(o).YMapHintContext);
      });
  }, []), !s || !p || !e ? /* @__PURE__ */ r.createElement(r.Fragment, null) : /* @__PURE__ */ r.createElement(s, { hint: t }, /* @__PURE__ */ r.createElement(L, { context: p }, e));
}, x = typeof document < "u" ? D : w, b = r.forwardRef(({ gridSize: e, method: t, ...n }, y) => {
  const { reactify: p, ymaps: u } = f(
    C
  ), [s, o] = M(), [m, i] = Y(() => {
    if (s) {
      const d = window[c.Clusterer];
      return [p.module(d).YMapClusterer, t || p.module(d).clusterByGrid];
    }
    return [];
  }, [s]);
  w(() => {
    window[c.Clusterer] ? o(window[c.Clusterer]) : u.import(c.Clusterer).then((d) => {
      window[c.Clusterer] = d, o(d);
    });
  }, []);
  const l = Y(() => {
    if (i && e)
      return i({ gridSize: e });
  }, [i, e]);
  return !m || !l ? /* @__PURE__ */ r.createElement(r.Fragment, null) : /* @__PURE__ */ r.createElement(
    m,
    {
      ref: y,
      method: l,
      ...n
    }
  );
});
class S {
  constructor(t = "") {
    this.eventTarget = document.appendChild(document.createComment(t));
  }
  on(t, n) {
    this.eventTarget.addEventListener(t, n);
  }
  once(t, n) {
    this.eventTarget.addEventListener(t, n, { once: !0 });
  }
  off(t, n) {
    this.eventTarget.removeEventListener(t, n);
  }
  emit(t, n) {
    return this.eventTarget.dispatchEvent(new CustomEvent(t, { detail: n }));
  }
}
const E = new S("ymaps3-components"), R = async ({
  key: e,
  lang: t = "ru_RU",
  coordorder: n,
  mode: y,
  apiKeys: p
}) => new Promise(async (u, s) => {
  try {
    if (window.ymaps3) {
      const o = window.ymaps3;
      await o.ready;
      const i = (await o.import("@yandex/ymaps3-reactify")).reactify.bindTo(r, h);
      u({
        ymaps: o,
        reactify: i
      });
    } else {
      const o = document.createElement("script");
      document.body.appendChild(o), o.type = "text/javascript";
      const m = new URLSearchParams({
        apikey: e,
        lang: t
      });
      n && m.set("coordorder", n), y && m.set("mode", y), o.src = `https://api-maps.yandex.ru/v3/?${m.toString()}`, o.onload = async () => {
        const i = window.ymaps3;
        await i.ready, p && i.getDefaultConfig().setApikeys(p);
        const d = (await i.import("@yandex/ymaps3-reactify")).reactify.bindTo(r, h);
        u({
          ymaps: i,
          reactify: d
        });
      }, o.onerror = s;
    }
  } catch {
  }
}), T = ({
  apiKey: e,
  lang: t,
  coordorder: n,
  mode: y,
  children: p,
  onLoad: u,
  onError: s,
  apiKeys: o
}) => {
  const [m, i] = M();
  return x(() => {
    R({ key: e, lang: t, coordorder: n, mode: y, apiKeys: o }).then((l) => {
      i(l), u == null || u(l), E.emit("ready");
    }).catch((l) => {
      s == null || s(l);
    });
  }, []), m ? /* @__PURE__ */ r.createElement(C.Provider, { value: m }, p) : /* @__PURE__ */ r.createElement(r.Fragment, null);
}, G = r.memo(T);
function a(e, t) {
  let n;
  const y = ({ ...p }, u) => {
    const { reactify: s, ymaps: o } = f(
      C
    ), [m, i] = M(!1);
    return x(() => {
      t ? window[t] ? (i(!0), n = s.module(window[t])[e]) : o.import(t).then((l) => {
        window[t] = l, s.module(l) && (i(!0), n = s.module(l)[e]);
      }) : (n = s.module(o)[e], i(!0));
    }, []), !n || !m ? null : /* @__PURE__ */ r.createElement(n, { ref: u, ...p });
  };
  return r.forwardRef(y);
}
const g = a("YMapGeolocationControl", c.Controls), I = a("YMapZoomControl", c.Controls), O = a("YMapClusterer", c.Clusterer), U = a("YMapDefaultMarker", c.Markers), Z = a("YMap"), k = a("YMapTileDataSource"), q = a("ThemeContext"), A = a("YMapControl"), W = a("YMapLayer"), _ = a("YMapMarker"), $ = a("YMapDefaultSchemeLayer"), J = a("YMapDefaultFeaturesLayer"), P = a("YMapDefaultSatelliteLayer"), Q = a("YMapListener"), V = a("YMapControls"), X = a("YMapControlButton"), z = a("YMapContainer"), K = a("YMapCollection"), N = a("YMapFeature"), ee = a("YMapFeatureDataSource"), te = () => new Promise((e) => {
  if (window.ymaps3) {
    const t = window.ymaps3;
    t.ready.then(() => e(t));
  } else
    E.once("ready", () => {
      e(window.ymaps3);
    });
});
export {
  q as ThemeContext,
  Z as YMap,
  O as YMapClusterer,
  K as YMapCollection,
  G as YMapComponentsProvider,
  z as YMapContainer,
  A as YMapControl,
  X as YMapControlButton,
  V as YMapControls,
  b as YMapCustomClusterer,
  J as YMapDefaultFeaturesLayer,
  U as YMapDefaultMarker,
  P as YMapDefaultSatelliteLayer,
  $ as YMapDefaultSchemeLayer,
  N as YMapFeature,
  ee as YMapFeatureDataSource,
  g as YMapGeolocationControl,
  B as YMapHint,
  H as YMapHintContext,
  W as YMapLayer,
  Q as YMapListener,
  _ as YMapMarker,
  k as YMapTileDataSource,
  I as YMapZoomControl,
  te as getYmaps3ReadyObject
};
